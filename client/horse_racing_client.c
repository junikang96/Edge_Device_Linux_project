#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <linux/fb.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <math.h>
#include <time.h>

#define FBDEV "/dev/fb0"
#define SERVER_IP "10.10.141.29"
#define PORT 25500
#define HORSES 8
#define TRACK_LENGTH 360
#define SCREEN_WIDTH 800
#define SCREEN_HEIGHT 480
#define HORSE_SIZE 100

// RGB888 → RGB565 변환 매크로
#define RGB565(r, g, b) ((((r) & 0xF8) << 8) | (((g) & 0xFC) << 3) | ((b) >> 3))

// 색상 정의 (RGB565 형식)
#define COLOR_GRASS  RGB565(0, 170, 0)      // 초록색 잔디
#define COLOR_DIRT   RGB565(139, 69, 19)    // 갈색 트랙
#define COLOR_WHITE  RGB565(255, 255, 255)  // 흰색

// BMP 파일 이름 배열
// BMP 파일 이름 배열 (경로 수정 버전)
const char *horse_bmps[HORSES] = {
    "./images/Black.bmp", "./images/Blue.bmp", "./images/Yellow.bmp", "./images/DeepBlue.bmp",
    "./images/Gray.bmp", "./images/Green.bmp", "./images/Mint.bmp", "./images/Red.bmp"
};


// 말 색상 이름 배열 (경주 결과 출력 시 사용)
const char *horse_colors[HORSES] = {
    "Black", "Blue", "Yellow", "DeepBlue",
    "Gray", "Green", "Mint", "Red"
};

// 프레임버퍼 관련 전역 변수
int fb_fd;
unsigned short *fbp;  // 16비트 RGB565 프레임버퍼
struct fb_var_screeninfo vinfo;
struct fb_fix_screeninfo finfo;

/*
 * font8x8_basic 배열은 ASCII 32(공백)부터 127까지의 8×8 비트맵 폰트 데이터입니다.
 * (출처: public domain)
 */
static const unsigned char font8x8_basic[128][8] = {
    [32] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    [33] = {0x00,0x00,0x5F,0x00,0x00,0x00,0x00,0x00},
    [34] = {0x00,0x07,0x00,0x07,0x00,0x00,0x00,0x00},
    [35] = {0x14,0x7F,0x14,0x7F,0x14,0x00,0x00,0x00},
    [36] = {0x24,0x2A,0x7F,0x2A,0x12,0x00,0x00,0x00},
    [37] = {0x23,0x13,0x08,0x64,0x62,0x00,0x00,0x00},
    [38] = {0x36,0x49,0x55,0x22,0x50,0x00,0x00,0x00},
    [39] = {0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00},
    [40] = {0x00,0x1C,0x22,0x41,0x00,0x00,0x00,0x00},
    [41] = {0x00,0x41,0x22,0x1C,0x00,0x00,0x00,0x00},
    [42] = {0x14,0x08,0x3E,0x08,0x14,0x00,0x00,0x00},
    [43] = {0x08,0x08,0x3E,0x08,0x08,0x00,0x00,0x00},
    [44] = {0x00,0x50,0x30,0x00,0x00,0x00,0x00,0x00},
    [45] = {0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00},
    [46] = {0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00},
    [47] = {0x20,0x10,0x08,0x04,0x02,0x00,0x00,0x00},
    [48] = {0x3E,0x51,0x49,0x45,0x3E,0x00,0x00,0x00},
    [49] = {0x00,0x42,0x7F,0x40,0x00,0x00,0x00,0x00},
    [50] = {0x42,0x61,0x51,0x49,0x46,0x00,0x00,0x00},
    [51] = {0x21,0x41,0x45,0x4B,0x31,0x00,0x00,0x00},
    [52] = {0x18,0x14,0x12,0x7F,0x10,0x00,0x00,0x00},
    [53] = {0x27,0x45,0x45,0x45,0x39,0x00,0x00,0x00},
    [54] = {0x3C,0x4A,0x49,0x49,0x30,0x00,0x00,0x00},
    [55] = {0x01,0x71,0x09,0x05,0x03,0x00,0x00,0x00},
    [56] = {0x36,0x49,0x49,0x49,0x36,0x00,0x00,0x00},
    [57] = {0x06,0x49,0x49,0x29,0x1E,0x00,0x00,0x00},
    [58] = {0x00,0x36,0x36,0x00,0x00,0x00,0x00,0x00},
    [59] = {0x00,0x56,0x36,0x00,0x00,0x00,0x00,0x00},
    [60] = {0x08,0x14,0x22,0x41,0x00,0x00,0x00,0x00},
    [61] = {0x14,0x14,0x14,0x14,0x14,0x00,0x00,0x00},
    [62] = {0x00,0x41,0x22,0x14,0x08,0x00,0x00,0x00},
    [63] = {0x02,0x01,0x51,0x09,0x06,0x00,0x00,0x00},
    [64] = {0x32,0x49,0x79,0x41,0x3E,0x00,0x00,0x00},
    [65] = {0x7E,0x11,0x11,0x11,0x7E,0x00,0x00,0x00},
    [66] = {0x7F,0x49,0x49,0x49,0x36,0x00,0x00,0x00},
    [67] = {0x3E,0x41,0x41,0x41,0x22,0x00,0x00,0x00},
    [68] = {0x7F,0x41,0x41,0x22,0x1C,0x00,0x00,0x00},
    [69] = {0x7F,0x49,0x49,0x49,0x41,0x00,0x00,0x00},
    [70] = {0x7F,0x09,0x09,0x09,0x01,0x00,0x00,0x00},
    [71] = {0x3E,0x41,0x49,0x49,0x7A,0x00,0x00,0x00},
    [72] = {0x7F,0x08,0x08,0x08,0x7F,0x00,0x00,0x00},
    [73] = {0x00,0x41,0x7F,0x41,0x00,0x00,0x00,0x00},
    [74] = {0x20,0x40,0x41,0x3F,0x01,0x00,0x00,0x00},
    [75] = {0x7F,0x08,0x14,0x22,0x41,0x00,0x00,0x00},
    [76] = {0x7F,0x40,0x40,0x40,0x40,0x00,0x00,0x00},
    [77] = {0x7F,0x02,0x0C,0x02,0x7F,0x00,0x00,0x00},
    [78] = {0x7F,0x04,0x08,0x10,0x7F,0x00,0x00,0x00},
    [79] = {0x3E,0x41,0x41,0x41,0x3E,0x00,0x00,0x00},
    [80] = {0x7F,0x09,0x09,0x09,0x06,0x00,0x00,0x00},
    [81] = {0x3E,0x41,0x51,0x21,0x5E,0x00,0x00,0x00},
    [82] = {0x7F,0x09,0x19,0x29,0x46,0x00,0x00,0x00},
    [83] = {0x46,0x49,0x49,0x49,0x31,0x00,0x00,0x00},
    [84] = {0x01,0x01,0x7F,0x01,0x01,0x00,0x00,0x00},
    [85] = {0x3F,0x40,0x40,0x40,0x3F,0x00,0x00,0x00},
    [86] = {0x1F,0x20,0x40,0x20,0x1F,0x00,0x00,0x00},
    [87] = {0x7F,0x20,0x18,0x20,0x7F,0x00,0x00,0x00},
    [88] = {0x63,0x14,0x08,0x14,0x63,0x00,0x00,0x00},
    [89] = {0x03,0x04,0x78,0x04,0x03,0x00,0x00,0x00},
    [90] = {0x61,0x51,0x49,0x45,0x43,0x00,0x00,0x00},
    [91] = {0x00,0x7F,0x41,0x41,0x00,0x00,0x00,0x00},
    [92] = {0x02,0x04,0x08,0x10,0x20,0x00,0x00,0x00},
    [93] = {0x00,0x41,0x41,0x7F,0x00,0x00,0x00,0x00},
    [94] = {0x04,0x02,0x01,0x02,0x04,0x00,0x00,0x00},
    [95] = {0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x00},
    [96] = {0x00,0x03,0x07,0x00,0x00,0x00,0x00,0x00},
    [97] = {0x20,0x54,0x54,0x54,0x78,0x00,0x00,0x00},
    [98] = {0x7F,0x48,0x44,0x44,0x38,0x00,0x00,0x00},
    [99] = {0x38,0x44,0x44,0x44,0x20,0x00,0x00,0x00},
    [100] = {0x38,0x44,0x44,0x48,0x7F,0x00,0x00,0x00},
    [101] = {0x38,0x54,0x54,0x54,0x18,0x00,0x00,0x00},
    [102] = {0x08,0x7E,0x09,0x01,0x02,0x00,0x00,0x00},
    [103] = {0x0C,0x52,0x52,0x52,0x3E,0x00,0x00,0x00},
    [104] = {0x7F,0x08,0x04,0x04,0x78,0x00,0x00,0x00},
    [105] = {0x00,0x44,0x7D,0x40,0x00,0x00,0x00,0x00},
    [106] = {0x20,0x40,0x44,0x3D,0x00,0x00,0x00,0x00},
    [107] = {0x7F,0x10,0x28,0x44,0x00,0x00,0x00,0x00},
    [108] = {0x00,0x41,0x7F,0x40,0x00,0x00,0x00,0x00},
    [109] = {0x7C,0x04,0x18,0x04,0x78,0x00,0x00,0x00},
    [110] = {0x7C,0x08,0x04,0x04,0x78,0x00,0x00,0x00},
    [111] = {0x38,0x44,0x44,0x44,0x38,0x00,0x00,0x00},
    [112] = {0x7C,0x14,0x14,0x14,0x08,0x00,0x00,0x00},
    [113] = {0x08,0x14,0x14,0x18,0x7C,0x00,0x00,0x00},
    [114] = {0x7C,0x08,0x04,0x04,0x08,0x00,0x00,0x00},
    [115] = {0x48,0x54,0x54,0x54,0x20,0x00,0x00,0x00},
    [116] = {0x04,0x3F,0x44,0x40,0x20,0x00,0x00,0x00},
    [117] = {0x3C,0x40,0x40,0x20,0x7C,0x00,0x00,0x00},
    [118] = {0x1C,0x20,0x40,0x20,0x1C,0x00,0x00,0x00},
    [119] = {0x3C,0x40,0x30,0x40,0x3C,0x00,0x00,0x00},
    [120] = {0x44,0x28,0x10,0x28,0x44,0x00,0x00,0x00},
    [121] = {0x0C,0x50,0x50,0x50,0x3C,0x00,0x00,0x00},
    [122] = {0x44,0x64,0x54,0x4C,0x44,0x00,0x00,0x00},
    [123] = {0x00,0x08,0x36,0x41,0x00,0x00,0x00,0x00},
    [124] = {0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00},
    [125] = {0x00,0x41,0x36,0x08,0x00,0x00,0x00,0x00},
    [126] = {0x10,0x08,0x08,0x10,0x08,0x00,0x00,0x00},
    [127] = {0x00,0x06,0x09,0x09,0x06,0x00,0x00,0x00}
};

/*
 * ── 문자 하나를 LCD에 출력 (폰트를 3배 확대하여 24×24 픽셀 크기로 출력, 90° 반시계 회전 적용) ──
 *
 * 원래 8×8 폰트를 3배 확대하면 24×24 픽셀이 되며,
 * 90° 반시계 회전 변환 공식: 
 *      new_x = orig_y
 *      new_y = (letter_size - 1) - orig_x
 * 여기서 letter_size = 8 * scale = 24.
 * (x, y)는 회전된 문자 블록의 좌상단 좌표입니다.)
 */
void draw_char_rotated(int x, int y, char c, unsigned short color) {
    int scale = 3;              // 확대 배수
    int letter_size = 8 * scale; // 24픽셀
    if (c < 32 || c > 127)
        return;
    for (int j = 0; j < 8; j++) {
        for (int i = 0; i < 8; i++) {
            if (font8x8_basic[(int)c][j] & (1 << (7 - i))) {
                // 원래의 픽셀 (i, j)를 scale 배율로 출력하면서 회전 적용
                for (int sy = 0; sy < scale; sy++) {
                    for (int sx = 0; sx < scale; sx++) {
                        int orig_x = i * scale + sx;  // 0 ~ 23
                        int orig_y = j * scale + sy;  // 0 ~ 23
                        // 90° 반시계 회전 변환:
                        // new_x = orig_y, new_y = (letter_size - 1) - orig_x
                        int dx = x + orig_y;
                        int dy = y + (letter_size - 1 - orig_x);
                        if (dx < SCREEN_WIDTH && dy < SCREEN_HEIGHT) {
                            int index = dx + dy * (finfo.line_length / 2);
                            fbp[index] = color;
                        }
                    }
                }
            }
        }
    }
}

/*
 * ── 문자열을 LCD에 출력 (각 문자를 회전 적용, 3배 확대, 오른쪽으로 배치)
 *
 * (x, y)는 첫 문자(회전된 상태)의 좌상단 좌표입니다.
 * 한 문자의 폭은 letter_size (24픽셀)입니다.
 */
void draw_string_rotated(int x, int y, const char *str, unsigned short color) {
    int scale = 3;
    int letter_size = 8 * scale; // 24
    while (*str) {
        draw_char_rotated(x, y, *str, color);
        x += letter_size; // 오른쪽으로 24픽셀 이동하여 다음 문자 출력
        str++;
    }
}

// ── 프레임버퍼 초기화 ──
void init_framebuffer() {
    fb_fd = open(FBDEV, O_RDWR);
    if (fb_fd == -1) {
        perror("에러: 프레임버퍼 장치를 열 수 없습니다");
        exit(1);
    }
    ioctl(fb_fd, FBIOGET_FSCREENINFO, &finfo);
    ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo);
    int screensize = vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / 8;
    fbp = (unsigned short *)mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0);
    if (fbp == MAP_FAILED) {
        perror("에러: 프레임버퍼 메모리 매핑 실패");
        exit(2);
    }
}

// ── 잔디 배경과 타원형 트랙 그리기 ──
void draw_track_background() {
    int cx = SCREEN_WIDTH / 2;
    int cy = SCREEN_HEIGHT / 2;
    
    for (int y = 0; y < SCREEN_HEIGHT; y++) {
        for (int x = 0; x < SCREEN_WIDTH; x++) {
            int dx = x - cx;
            int dy = y - cy;
            double distance = (dx * dx) / (350.0 * 350.0) + (dy * dy) / (220.0 * 220.0);
            double inner_distance = (dx * dx) / (210.0 * 210.0) + (dy * dy) / (110.0 * 110.0);
            int index = x + y * (finfo.line_length / 2);
            if (distance <= 1.0 && inner_distance > 1.0)
                fbp[index] = COLOR_DIRT;
            else
                fbp[index] = COLOR_GRASS;
        }
    }
}

// ── BMP 이미지 출력 (16비트 RGB565 지원) ──
void draw_bmp(const char *filename, int x, int y) {
    int bmp_fd = open(filename, O_RDONLY);
    if (bmp_fd < 0) {
        printf("BMP 파일 열기 실패: %s\n", filename);
        return;
    }
    unsigned char header[54];
    read(bmp_fd, header, 54);
    int width = *(int *)&header[18];
    int height = *(int *)&header[22];
    int data_offset = *(int *)&header[10];
    int row_padded = (width * 3 + 3) & ~3;
    unsigned char *bmp_data = (unsigned char *)malloc(row_padded * height);
    lseek(bmp_fd, data_offset, SEEK_SET);
    read(bmp_fd, bmp_data, row_padded * height);
    close(bmp_fd);
    
    for (int j = 0; j < height; j++) {
        for (int i = 0; i < width; i++) {
            int bmp_index = (height - 1 - j) * row_padded + i * 3;
            unsigned char b = bmp_data[bmp_index];
            unsigned char g = bmp_data[bmp_index + 1];
            unsigned char r = bmp_data[bmp_index + 2];
            if (r == 255 && g == 255 && b == 255)
                continue;
            unsigned short color = RGB565(r, g, b);
            int index = (x + i) + (y + j) * (finfo.line_length / 2);
            fbp[index] = color;
        }
    }
    free(bmp_data);
}

// ── 말들의 위치에 따라 BMP 이미지 출력 ──
void draw_horses(int positions[]) {
    draw_track_background();
    for (int i = 0; i < HORSES; i++) {
        int angle = positions[i] % TRACK_LENGTH;
        int x = SCREEN_WIDTH / 2 + (SCREEN_WIDTH / 3) * cos(angle * M_PI / 180) - HORSE_SIZE / 2;
        int y = SCREEN_HEIGHT / 2 + (SCREEN_HEIGHT / 3) * sin(angle * M_PI / 180) - HORSE_SIZE / 2;
        draw_bmp(horse_bmps[i], x, y);
    }
}

/*
 * ── 경주 결과를 터미널과 LCD에 출력 ──
 *
 * 기존 코드에서는 말 finishing 순서대로 결과가 출력되어 3등, 2등, 1등 순으로 나타났다면,
 * 아래 함수는 1등, 2등, 3등 순서(오름차순)로 결과를 출력합니다.
 * rankings 배열에는 각 말(i번째 말)에 대해 finishing rank가 저장되어 있습니다.
 */
void print_race_results(int rankings[]) {
    printf("경주 결과:\n");
    char result_str[64];
    int line = 0;
    // LCD에 결과 출력: 좌측 상단 (50, 50)에서 시작, 각 줄 간격 24픽셀 (회전된 문자 높이)
    draw_string_rotated(50, 50, "Race Results:", COLOR_WHITE);
    line++;
    // 1등부터 3등까지 오름차순으로 출력
    for (int r = 1; r <= 3; r++) {
        for (int i = 0; i < HORSES; i++) {
            if (rankings[i] == r) {
                char suffix[3];
                if (r == 1)
                    strcpy(suffix, "st");
                else if (r == 2)
                    strcpy(suffix, "nd");
                else if (r == 3)
                    strcpy(suffix, "rd");
                else
                    strcpy(suffix, "th");
                sprintf(result_str, "%d%s: %s Horse %d", r, suffix, horse_colors[i], i + 1);
                printf("%s\n", result_str);
                draw_string_rotated(50, 50 + line * 24, result_str, COLOR_WHITE);
                line++;
            }
        }
    }
}

int main() 
{
    int sockfd;
    struct sockaddr_in server_addr;
    char buffer[1024];
    int positions[HORSES] = {0};
    int finished = 0, rank = 1;
    int rankings[HORSES] = {0};

    // 프레임버퍼 초기화 (LCD 출력용)
    init_framebuffer();

    // UDP 소켓 생성
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        perror("소켓 생성 실패");
        exit(1);
    }
    // 서버 주소 설정
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
    server_addr.sin_port = htons(PORT);

    // 초기 화면에서 클라이언트는 아무 키나 입력하면 서버로 시작 신호를 보냄
    printf("Press any key to start the game: ");
    getchar(); // 입력된 키를 읽고 바로 진행

    // 서버에 시작 신호 전송
    int let = sendto(sockfd, "1", sizeof("1"), 0, (struct sockaddr *)&server_addr, sizeof(server_addr));
    if(let > 0)
    {
        printf("error... try again");
    }

    // 경주 진행: 3마리의 말이 완주할 때까지
    while (finished < 3) 
    {
        recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);
        sscanf(buffer, "%d %d %d %d %d %d %d %d",
               &positions[0], &positions[1], &positions[2], &positions[3],
               &positions[4], &positions[5], &positions[6], &positions[7]);
        for (int i = 0; i < HORSES; i++) {
            if (positions[i] >= TRACK_LENGTH && rankings[i] == 0) {
                rankings[i] = rank++;
                finished++;
            }
        }
        draw_horses(positions);
    }

    print_race_results(rankings);

    close(sockfd);
    return 0;
}
